"""Enhanced CLI for Oracle WMS Tap with additional commands."""
# Copyright (c) 2025 FLEXT Team
# Licensed under the MIT License

from __future__ import annotations

import asyncio
import json
import logging
import os
import sys
from pathlib import Path
from typing import Any

import click
from dotenv import load_dotenv

# Use centralized logger from flext-observability - ELIMINATE DUPLICATION
from flext_observability.logging import get_logger
from flext_tap_oracle_wms.discovery import EntityDiscovery
from flext_tap_oracle_wms.tap import TapOracleWMS

logger = get_logger(__name__)


@click.group()
def cli() -> None:
    """Enhanced Oracle WMS Tap CLI."""
    pass


@cli.command()
@click.option("--config", default=".env", help="Configuration file or .env")
def validate(config: str) -> None:
    """Validate Oracle WMS Tap configuration."""
    click.echo("ðŸ” Validating Oracle WMS Tap configuration...")

    try:
        tap_config = _load_config(config)
        click.echo("âœ… Configuration loaded successfully")

        # Validate required fields
        required = ["base_url"]
        missing = [field for field in required if not tap_config.get(field)]

        if missing:
            click.echo(f"âŒ Missing required fields {', '.join(missing)}")
            sys.exit(1)

        # Validate URL format
        base_url = tap_config["base_url"]
        if not base_url.startswith(("http://", "https://")):
            click.echo("âŒ base_url must start with http:// or https://")
            sys.exit(1)

        click.echo("âœ… Configuration is valid")

    except (ValueError, KeyError, TypeError, RuntimeError) as e:
        logger.exception("âŒ CONFIGURATION ERROR - Invalid tap configuration")
        click.echo(f"âŒ Configuration error: {e}")
        sys.exit(1)


@cli.command()
@click.option("--config", default=".env", help="Configuration file or .env")
def check_connectivity(config: str) -> None:
    """Check Oracle WMS connectivity."""
    click.echo("ðŸŒ Checking Oracle WMS connectivity...")

    try:
        tap_config = _load_config(config)
        discovery = EntityDiscovery(tap_config)

        # Try to discover entities
        result = asyncio.run(discovery.discover_entities())

        if result:
            click.echo(f"âœ… Connected successfully! Found {len(result)} entities")
            for entity in list(result.keys())[:5]:
                click.echo(f"  - {entity}")
            max_display = 5
            if len(result) > max_display:
                click.echo(f"  ... and {len(result) - max_display} more")
        else:
            click.echo("âš ï¸  Connected but no entities found")

    except (ValueError, KeyError, TypeError, RuntimeError) as e:
        logger.exception("âŒ CONNECTION FAILED - Cannot connect to Oracle WMS")
        click.echo(f"âŒ Connection failed: {e}")
        sys.exit(1)


@cli.command()
@click.option("--config", default=".env", help="Configuration file or .env")
def list_entities(config: str) -> None:
    """List Oracle WMS entities."""
    click.echo("ðŸ“‹ Listing Oracle WMS entities...")

    try:
        tap_config = _load_config(config)
        discovery = EntityDiscovery(tap_config)

        entities = asyncio.run(discovery.discover_entities())

        if not entities:
            click.echo("No entities found")
            return

        click.echo(f"\nFound {len(entities)} entities")
        click.echo("-" * 40)

        for i, (name, url) in enumerate(entities.items(), 1):
            click.echo(f"{i:2d}. {name}")
            click.echo(f"    URL: {url}")

    except (ValueError, KeyError, TypeError, RuntimeError) as e:
        logger.exception("âŒ ENTITY LISTING FAILED - Cannot list entities")
        click.echo(f"âŒ Error listing entities: {e}")
        sys.exit(1)


@cli.command()
@click.option("--config", default=".env", help="Configuration file or .env")
@click.argument("entity_name")
def describe_entity(config: str, entity_name: str) -> None:
    """Describe Oracle WMS entity."""
    click.echo(f"ðŸ” Describing entity: {entity_name}")

    try:
        tap_config = _load_config(config)
        discovery = EntityDiscovery(tap_config)

        metadata = asyncio.run(discovery.describe_entity(entity_name))

        if not metadata:
            click.echo(f"âŒ Entity '{entity_name}' not found or no metadata available")
            sys.exit(1)

        click.echo(f"\nEntity {entity_name}")
        click.echo("-" * 40)

        if "fields" in metadata:
            fields = metadata["fields"]
            click.echo(f"Fields ({len(fields)}):")
            for field_name, field_info in fields.items():
                field_type = field_info.get("type", "unknown")
                required = " (required)" if field_info.get("required") else ""
                max_length = (
                    f" max:{field_info['max_length']}"
                    if field_info.get("max_length")
                    else ""
                )
                click.echo(f"  - {field_name}: {field_type}{max_length}{required}")

        if "parameters" in metadata:
            params = metadata["parameters"]
            click.echo(f"\nParameters: {', '.join(params)}")

    except (ValueError, KeyError, TypeError, RuntimeError) as e:
        logger.exception("âŒ ENTITY DESCRIPTION FAILED - Cannot describe entity")
        click.echo(f"âŒ Error describing entity: {e}")
        sys.exit(1)


# ðŸš¨ COMMAND PERMANENTLY DELETED: sample_data
# This command is FORBIDDEN - schema discovery uses ONLY API metadata describe


@cli.command()
@click.option("--config", default=".env", help="Configuration file or .env")
@click.option("--output", default="catalog.json", help="Output catalog file")
def generate_catalog(config: str, output: str) -> None:
    """Generate Singer catalog."""
    click.echo("ðŸ“„ Generating Singer catalog...")

    try:
        tap_config = _load_config(config)
        tap = TapOracleWMS(config=tap_config)

        catalog = tap.catalog_dict

        with Path(output).open("w", encoding="utf-8") as f:
            json.dump(catalog, f, indent=2)

        streams: list[Any] = catalog.get("streams", [])
        click.echo(f"âœ… Catalog generated: {output}")
        click.echo(f"   Streams: {len(streams)}")

        for stream in streams[:5]:
            if isinstance(stream, dict):
                click.echo(f"   - {stream.get('stream', 'unknown')}")
            else:
                click.echo(f"   - {stream!s}")

        max_display_streams = 5
        if len(streams) > max_display_streams:
            click.echo(f"   ... and {len(streams) - max_display_streams} more streams")

    except (ValueError, KeyError, TypeError, RuntimeError) as e:
        logger.exception("âŒ CATALOG GENERATION FAILED - Cannot generate catalog")
        click.echo(f"âŒ Error generating catalog: {e}")
        sys.exit(1)


@cli.command()
@click.option("--config", default=".env", help="Configuration file or .env")
def test_singer(config: str) -> None:
    """Test Singer protocol compliance."""
    click.echo("ðŸŽ¯ Testing Singer protocol compliance...")

    try:
        tap_config = _load_config(config)
        tap = TapOracleWMS(config=tap_config)

        # Test basic Singer interface
        tests = [
            ("name", "tap name", hasattr(tap, "name")),
            ("config", "configuration", hasattr(tap, "config")),
            ("catalog_dict", "catalog generation", hasattr(tap, "catalog_dict")),
            ("state_dict", "state management", hasattr(tap, "state_dict")),
            ("discover_streams", "stream discovery", hasattr(tap, "discover_streams")),
        ]

        all_passed = True
        for _attr, description, passed in tests:
            status = "âœ…" if passed else "âŒ"
            click.echo(f"  {status} {description}")
            if not passed:
                all_passed = False

        # Test tap name convention
        if hasattr(tap, "name") and tap.name == "tap-oracle-wms":
            click.echo("  âœ… tap name follows convention")
        else:
            click.echo("  âŒ tap name doesn't follow convention")
            all_passed = False

        if all_passed:
            click.echo("\nðŸŽ‰ All Singer protocol tests passed!")
        else:
            click.echo("\nâŒ Some Singer protocol tests failed!")
            sys.exit(1)

    except (ValueError, KeyError, TypeError, RuntimeError) as e:
        logger.exception("âŒ SINGER TEST FAILED - Singer compatibility test failed")
        click.echo(f"âŒ Error testing Singer compliance: {e}")
        sys.exit(1)


@cli.command()
@click.option("--config", default=".env", help="Configuration file or .env")
@click.option("--entity", help="Test specific entity")
def test_extraction(config: str, entity: str | None) -> None:
    """Test data extraction."""
    click.echo("ðŸš€ Testing data extraction...")

    try:
        tap_config = _load_config(config)

        # Override record limit for testing
        tap_config["record_limit"] = 5

        discovery = EntityDiscovery(tap_config)
        entities = asyncio.run(discovery.discover_entities())

        if not entities:
            click.echo("âŒ No entities found for testing")
            sys.exit(1)

        # Test specific entity or first available
        test_entity = entity or next(iter(entities.keys()))

        if test_entity not in entities:
            click.echo(f"âŒ Entity '{test_entity}' not found")
            sys.exit(1)

        click.echo(f"Testing extraction from: {test_entity}")

        # Test schema generation using ONLY API metadata
        try:
            metadata = asyncio.run(discovery.describe_entity(test_entity))
            if metadata and "fields" in metadata:
                field_count = len(metadata["fields"])
                click.echo(f"âœ… Successfully got metadata with {field_count} fields")
                click.echo(f"   Metadata fields {', '.join(metadata['fields'].keys())}")
            else:
                click.echo("âš ï¸  No metadata available for extraction test")
        except (ValueError, KeyError, TypeError, RuntimeError, ConnectionError) as e:
            click.echo(f"âŒ Error getting metadata: {e}")

    except (ValueError, KeyError, TypeError, RuntimeError) as e:
        logger.exception("âŒ EXTRACTION TEST FAILED - Data extraction test failed")
        click.echo(f"âŒ Error testing extraction: {e}")
        sys.exit(1)


def _load_config(config_path: str) -> dict[str, Any]:
    """Load configuration from file or environment."""
    if config_path == ".env" or config_path.endswith(".env"):
        # Load from environment variables
        if Path(config_path).exists():
            load_dotenv(config_path)

        return {
            "base_url": os.getenv("TAP_ORACLE_WMS_BASE_URL", ""),
            "username": os.getenv("TAP_ORACLE_WMS_USERNAME", ""),
            "password": os.getenv("TAP_ORACLE_WMS_PASSWORD", ""),
            "company_code": os.getenv("TAP_ORACLE_WMS_COMPANY_CODE", "*"),
            "facility_code": os.getenv("TAP_ORACLE_WMS_FACILITY_CODE", "*"),
            "page_size": int(os.getenv("TAP_ORACLE_WMS_PAGE_SIZE", "100")),
            "request_timeout": int(os.getenv("TAP_ORACLE_WMS_REQUEST_TIMEOUT", "120")),
            "verify_ssl": os.getenv("TAP_ORACLE_WMS_VERIFY_SSL", "true").lower() == "true",
            "record_limit": int(os.getenv("TAP_ORACLE_WMS_RECORD_LIMIT", "100")),
        }
    
    # Load from JSON file
    with Path(config_path).open(encoding="utf-8") as f:
        return dict(json.load(f))


if __name__ == "__main__":
    cli()
